using STRCore.FEMElements;
using STRCore.STRElements;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace STRCore.Helpers
{
    internal static class ModelHelper 
    {
        public static void ClearStrucutralModel()
        {
            STRController.CurrentController.Structure.FEMNodes.Clear();
            STRController.CurrentController.Structure.FEMBars.Clear();
            STRController.CurrentController.Structure.LastFEMNodeId = 0;
            STRController.CurrentController.Structure.LastFEMBarId = 0;
            foreach (STRLine line in STRController.CurrentController.Structure.Lines)
            {
                line.FEMBars.Clear();
            }

            List<STRNode> autoNodes = new List<STRNode>();
            foreach (STRNode node in STRController.CurrentController.Structure.Nodes)
            {
                if (node.IsAutoGenerated)
                    autoNodes.Add(node);
            }

            foreach (STRNode autoNode in autoNodes)
                STRController.CurrentController.Structure.Nodes.Remove(autoNode);
        }
        internal static void GenerateFiniteElements()
        {
            GenerateFEMObjectsFromSTRNodes();
            GenerateFEMObjectsFromSTRLines();
        }
        private static void GenerateFEMObjectsFromSTRLines()
        {
            // Cycle through all the STRLines
            for (int i = 0; i < STRController.CurrentController.Structure.Lines.Count; i++)
            {
                // Make sure that no isolated nodes exisit

                // Search for all nodes that are on a line
                STRLine line = STRController.CurrentController.Structure.Lines[1];
                STRNode node1 = line.Node1;
                STRNode node2 = line.Node2;

                LineSegment segment = new LineSegment(node1.X, node1.Y, node1.Z, node2.X, node2.Y, node2.Z);
                List<STRNode> nodesOnSegmentSorted = GetSortedSTRNodes(segment);
                List<FEMNode> femNodesOnSegmentSorted = new List<FEMNode>();

                for (int j = 0; j < nodesOnSegmentSorted.Count; j++)
                {
                    STRNode strNode = nodesOnSegmentSorted[j];
                    FEMNode femNode = STRController.CurrentController.DefineFEMNode(strNode.X, strNode.Y, strNode.Z);

                    femNode.CorrespondingSTRNode = strNode;
                    femNode.IsMasterNode = true;
                    femNode.IsSlaveNode = false;
                    femNode.IsSupportNode = false;
                    femNode.MasterFEMNode = null;
                    femNode.SlaveFEMNode = null;

                    femNodesOnSegmentSorted.Add(femNode);
                }

                // Deal with releases 
                int startIndex = 0;
                int endIndex = femNodesOnSegmentSorted.Count - 1;

                if (line.Release != null)
                {
                    // The line got released
                    STRRelease release = line.Release;
                    bool isStartReleased = release.KUxStart != Global.Constants.RigidKU ||
                        release.KUyStart != Global.Constants.RigidKU ||
                        release.KUzStart != Global.Constants.RigidKU ||
                        release.KRxStart != Global.Constants.RigidKR ||
                        release.KRyStart != Global.Constants.RigidKR ||
                        release.KRzStart != Global.Constants.RigidKR;

                    bool isEndReleased = release.KUxEnd != Global.Constants.RigidKU ||
                        release.KUyEnd != Global.Constants.RigidKU ||
                        release.KUzEnd != Global.Constants.RigidKU ||
                        release.KRxEnd != Global.Constants.RigidKR ||
                        release.KRyEnd != Global.Constants.RigidKR ||
                        release.KRzEnd != Global.Constants.RigidKR;

                    if (isStartReleased)
                    {
                        // Define a small longitudinal shift
                        double[] Vx_1 = line.Vx;
                        double[] vx = new double[3];
                        vx[0] = Vx_1[0] * 10.0 * Global.Constants.Epsilon;
                        vx[1] = Vx_1[1] * 10.0 * Global.Constants.Epsilon;
                        vx[2] = Vx_1[2] * 10.0 * Global.Constants.Epsilon;

                        FEMNode firstNode = femNodesOnSegmentSorted[0];
                        FEMNode femNode = STRController.CurrentController.DefineFEMNode(firstNode.X + vx[0], firstNode.Y + vx[1], firstNode.Z + vx[2]);

                        femNode.CorrespondingSTRNode = firstNode.CorrespondingSTRNode;
                        femNode.IsMasterNode = false;
                        femNode.IsSlaveNode = true;
                        femNode.MasterFEMNode = firstNode;
                        femNodesOnSegmentSorted.Insert(1, femNode);
                        startIndex++;
                        endIndex++;

                        FEMBarSpring femBar = STRController.CurrentController.DefineFEMBarSpring(firstNode, femNode);
                        femBar.KUx = release.KUxStart;
                        femBar.KUy = release.KUyStart;
                        femBar.KUz = release.KUzStart;
                        femBar.KRx = release.KRxStart;
                        femBar.KRy = release.KRyStart;
                        femBar.KRz = release.KRzStart;
                        femBar.CorrespondingSTRLine = line;

                    }
                    if (isEndReleased)
                    {
                        double[] Vx_1 = line.Vx;
                        double[] vx = new double[3];
                        vx[0] = Vx_1[0] * -10.0 * Global.Constants.Epsilon;
                        vx[1] = Vx_1[1] * -10.0 * Global.Constants.Epsilon;
                        vx[2] = Vx_1[2] * -10.0 * Global.Constants.Epsilon;

                        FEMNode lastNode = femNodesOnSegmentSorted[femNodesOnSegmentSorted.Count - 1];
                        FEMNode femNode = STRController.CurrentController.DefineFEMNode(lastNode.X + vx[0], lastNode.Y + vx[1], lastNode.Z + vx[2]);
                        femNode.CorrespondingSTRNode = lastNode.CorrespondingSTRNode;
                        femNode.IsMasterNode = false;
                        femNode.IsSlaveNode = true;
                        femNode.MasterFEMNode = lastNode;
                        femNodesOnSegmentSorted.Insert(femNodesOnSegmentSorted.Count - 1, femNode);

                        FEMBarSpring femBar = STRController.CurrentController.DefineFEMBarSpring(femNode, lastNode);
                        femBar.KUx = release.KUxEnd;
                        femBar.KUy = release.KUyEnd;
                        femBar.KUz = release.KUzEnd;
                        femBar.KRx = release.KRxEnd;
                        femBar.KRy = release.KRyEnd;
                        femBar.KRz = release.KRzEnd;
                        femBar.CorrespondingSTRLine = line;
                    }
                }

                // Discritize the strLineinto fembeam based on the nodes on the bar that are sorted
                for (int j = startIndex; j < endIndex; j++)
                {
                    FEMNode femNode1N = femNodesOnSegmentSorted[j];
                    FEMNode femNode2N = femNodesOnSegmentSorted[j+1];
                    FEMBarBeam femBar = STRController.CurrentController.DefineFEMBarBeam(femNode1N, femNode2N, line.Section, line.Material);
                    femBar.CorrespondingSTRLine = line;
                    line.FEMBars.Add(femBar);
                }
            }
        }
        private static List<STRNode> GetSortedSTRNodes(LineSegment segment)
        {
            STRStructure strucutre = STRController.CurrentController.Structure;
            List<STRNode> nodesOnSegment = new List<STRNode>();
            List<double> tValues = new List<double>();
            for (int i = 0; i < strucutre.Nodes.Count; i++)
            {
                STRNode node = strucutre.Nodes[i];
                bool isOnLine = segment.IsOnLineSegment(node.X, node.Y, node.Z);
                if (isOnLine)
                {
                    // paramteric line eq:
                    // x = at + x0
                    // y = bt + y0
                    // z = ct + z0
                    // find the t value of every point to sort points
                    nodesOnSegment.Add(node);
                    double t = segment.GetTValue(node.X, node.Y, node.Z);
                    tValues.Add(t);
                }
            }

            // rearrange points in sorted order
            List <STRNode> nodesOnSementSorted = new List<STRNode>();
            List<double> tValuesSorted = new List<double>();

            while (tValues.Count > 0)
            {
                int minElementIndex = tValues.IndexOf(tValues.Min());
                double minValue = tValues[minElementIndex];
                STRNode minNode = nodesOnSegment[minElementIndex];
                tValuesSorted.Add(minValue);
                tValues.RemoveAt(minElementIndex);
                nodesOnSegment.RemoveAt(minElementIndex);
            }
            return nodesOnSementSorted;
        }

        private static void GenerateFEMObjectsFromSTRNodes()
        {
            STRStructure structure = STRController.CurrentController.Structure;
            for (int i = 0; i < structure.Nodes.Count; i++)
            {
                STRNode node = structure.Nodes[i];
                
                FEMNode femMasterNode = STRController.CurrentController.DefineFEMNode(node.X, node.Y, node.Z);
                node.CorrespondingFEMNode = femMasterNode;
                femMasterNode.IsMasterNode = true;
                femMasterNode.IsSupportNode = false;
                femMasterNode.CorrespondingSTRNode = node;
                femMasterNode.IsSlaveNode = false;
                femMasterNode.MasterFEMNode = null;

                if (node.Support != null)
                {
                    Random gen = new Random();
                    double randomNumber = (double)(gen.Next(0, 1000) / 1000.0) * 5.0 + 2.0;
                    double deltaX = randomNumber * Global.Constants.FEMEpsilon;
                    FEMNode femSlaveNode = STRController.CurrentController.DefineFEMNode(node.X + deltaX, node.Y, node.Z);
                    femSlaveNode.IsMasterNode = false;
                    femSlaveNode.IsSupportNode = true;
                    femSlaveNode.CorrespondingSTRNode = node;
                    femSlaveNode.IsSlaveNode = true;
                    femSlaveNode.SlaveFEMNode = null;

                    femSlaveNode.MasterFEMNode = femMasterNode;
                    femMasterNode.SlaveFEMNode = femSlaveNode;

                    STRSupport support = node.Support;
                    FEMBarSpring femBar = STRController.CurrentController.DefineFEMBarSpring(femMasterNode, femSlaveNode);
                    
                    // use the spring constants
                    femBar.KUx = support.KUx;
                    femBar.KUy = support.KUy;
                    femBar.KUz = support.KUz;
                    femBar.KRx = support.KRx;
                    femBar.KRy = support.KRy;
                    femBar.KRz = support.KRz;
                }
            }
        }
        internal static void PrepareStructuralModel()
        {
            // Find if any lines intersect, and create nodes at the intersection of lines
            CreateSTRNodeFromLineXLine();
        }
        private static void CreateSTRNodeFromLineXLine()
        {
            STRStructure structure = STRController.CurrentController.Structure;

            for (int i = 0; i < structure.Lines.Count; i++)
            {
                STRLine line1 = structure.Lines[i];
                STRNode start1 = line1.Node1;
                STRNode end1 = line1.Node2;
                LineSegment segment1 = new LineSegment(start1.X, start1.Y, start1.Z, end1.X, end1.Y, end1.Z);
                for (int j = 0; j < structure.Lines.Count; j++)
                {
                    STRLine line2 = structure.Lines[j];
                    if (line1.Id == line2.Id) continue;
                    STRNode start2 = line2.Node1;
                    STRNode end2 = line2.Node2;
                    LineSegment segment2 = new LineSegment(start2.X, start2.Y, start2.Z, end2.X, end2.Y, end2.Z);

                    double[] intersectionPoint = LineSegment.LineSegmentXLineSegment(segment1, segment2);
                    if (double.IsNaN(intersectionPoint[0]) ||
                        double.IsNaN(intersectionPoint[1]) ||
                        double.IsNaN(intersectionPoint[2]))
                        continue;
                    STRNode node = STRController.CurrentController.DefineSTRNode(intersectionPoint[0], intersectionPoint[1], intersectionPoint[2]);
                    node.IsAutoGenerated = true;
                }
            }
        }
    }
}
